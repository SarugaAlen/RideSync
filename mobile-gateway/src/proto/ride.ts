// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.30.1
// source: ride.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "rideservice";

export interface CreateRideRequest {
  driverId: string;
  startLocation: string;
  endLocation: string;
  passengerIds: string[];
  dateTime: string;
}

export interface CreateRideResponse {
  rideId: string;
}

export interface GetRideRequest {
  rideId: string;
}

export interface GetRideResponse {
  rideId: string;
  driverId: string;
  startLocation: string;
  endLocation: string;
  passengerIds: string[];
  dateTime: string;
  status: string;
}

export interface ListRidesRequest {
  driverId: string;
}

export interface ListRidesResponse {
  rides: GetRideResponse[];
}

export interface UpdateRideRequest {
  rideId: string;
  driverId: string;
  startLocation: string;
  endLocation: string;
  passengerIds: string[];
  dateTime: string;
  status: string;
}

export interface UpdateRideResponse {
  success: boolean;
}

export interface DeleteRideRequest {
  rideId: string;
}

export interface DeleteRideResponse {
  success: boolean;
}

export interface FindRidesByLocationRequest {
  startLocation: string;
  endLocation: string;
}

export interface FindRidesByLocationResponse {
  rides: GetRideResponse[];
}

export interface JoinRideRequest {
  rideId: string;
  passengerId: string;
}

export interface JoinRideResponse {
  success: boolean;
}

export interface LeaveRideRequest {
  rideId: string;
  passengerId: string;
}

export interface LeaveRideResponse {
  success: boolean;
}

export interface ChangeRideStatusRequest {
  rideId: string;
  status: string;
}

export interface ChangeRideStatusResponse {
  success: boolean;
}

function createBaseCreateRideRequest(): CreateRideRequest {
  return { driverId: "", startLocation: "", endLocation: "", passengerIds: [], dateTime: "" };
}

export const CreateRideRequest: MessageFns<CreateRideRequest> = {
  encode(message: CreateRideRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.driverId !== "") {
      writer.uint32(10).string(message.driverId);
    }
    if (message.startLocation !== "") {
      writer.uint32(18).string(message.startLocation);
    }
    if (message.endLocation !== "") {
      writer.uint32(26).string(message.endLocation);
    }
    for (const v of message.passengerIds) {
      writer.uint32(34).string(v!);
    }
    if (message.dateTime !== "") {
      writer.uint32(42).string(message.dateTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateRideRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRideRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.driverId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.startLocation = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.endLocation = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.passengerIds.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.dateTime = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRideRequest {
    return {
      driverId: isSet(object.driverId) ? globalThis.String(object.driverId) : "",
      startLocation: isSet(object.startLocation) ? globalThis.String(object.startLocation) : "",
      endLocation: isSet(object.endLocation) ? globalThis.String(object.endLocation) : "",
      passengerIds: globalThis.Array.isArray(object?.passengerIds)
        ? object.passengerIds.map((e: any) => globalThis.String(e))
        : [],
      dateTime: isSet(object.dateTime) ? globalThis.String(object.dateTime) : "",
    };
  },

  toJSON(message: CreateRideRequest): unknown {
    const obj: any = {};
    if (message.driverId !== "") {
      obj.driverId = message.driverId;
    }
    if (message.startLocation !== "") {
      obj.startLocation = message.startLocation;
    }
    if (message.endLocation !== "") {
      obj.endLocation = message.endLocation;
    }
    if (message.passengerIds?.length) {
      obj.passengerIds = message.passengerIds;
    }
    if (message.dateTime !== "") {
      obj.dateTime = message.dateTime;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateRideRequest>, I>>(base?: I): CreateRideRequest {
    return CreateRideRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateRideRequest>, I>>(object: I): CreateRideRequest {
    const message = createBaseCreateRideRequest();
    message.driverId = object.driverId ?? "";
    message.startLocation = object.startLocation ?? "";
    message.endLocation = object.endLocation ?? "";
    message.passengerIds = object.passengerIds?.map((e) => e) || [];
    message.dateTime = object.dateTime ?? "";
    return message;
  },
};

function createBaseCreateRideResponse(): CreateRideResponse {
  return { rideId: "" };
}

export const CreateRideResponse: MessageFns<CreateRideResponse> = {
  encode(message: CreateRideResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rideId !== "") {
      writer.uint32(10).string(message.rideId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateRideResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRideResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rideId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRideResponse {
    return { rideId: isSet(object.rideId) ? globalThis.String(object.rideId) : "" };
  },

  toJSON(message: CreateRideResponse): unknown {
    const obj: any = {};
    if (message.rideId !== "") {
      obj.rideId = message.rideId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateRideResponse>, I>>(base?: I): CreateRideResponse {
    return CreateRideResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateRideResponse>, I>>(object: I): CreateRideResponse {
    const message = createBaseCreateRideResponse();
    message.rideId = object.rideId ?? "";
    return message;
  },
};

function createBaseGetRideRequest(): GetRideRequest {
  return { rideId: "" };
}

export const GetRideRequest: MessageFns<GetRideRequest> = {
  encode(message: GetRideRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rideId !== "") {
      writer.uint32(10).string(message.rideId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRideRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRideRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rideId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRideRequest {
    return { rideId: isSet(object.rideId) ? globalThis.String(object.rideId) : "" };
  },

  toJSON(message: GetRideRequest): unknown {
    const obj: any = {};
    if (message.rideId !== "") {
      obj.rideId = message.rideId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRideRequest>, I>>(base?: I): GetRideRequest {
    return GetRideRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRideRequest>, I>>(object: I): GetRideRequest {
    const message = createBaseGetRideRequest();
    message.rideId = object.rideId ?? "";
    return message;
  },
};

function createBaseGetRideResponse(): GetRideResponse {
  return { rideId: "", driverId: "", startLocation: "", endLocation: "", passengerIds: [], dateTime: "", status: "" };
}

export const GetRideResponse: MessageFns<GetRideResponse> = {
  encode(message: GetRideResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rideId !== "") {
      writer.uint32(10).string(message.rideId);
    }
    if (message.driverId !== "") {
      writer.uint32(18).string(message.driverId);
    }
    if (message.startLocation !== "") {
      writer.uint32(26).string(message.startLocation);
    }
    if (message.endLocation !== "") {
      writer.uint32(34).string(message.endLocation);
    }
    for (const v of message.passengerIds) {
      writer.uint32(42).string(v!);
    }
    if (message.dateTime !== "") {
      writer.uint32(50).string(message.dateTime);
    }
    if (message.status !== "") {
      writer.uint32(58).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRideResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRideResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rideId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.driverId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.startLocation = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.endLocation = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.passengerIds.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.dateTime = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRideResponse {
    return {
      rideId: isSet(object.rideId) ? globalThis.String(object.rideId) : "",
      driverId: isSet(object.driverId) ? globalThis.String(object.driverId) : "",
      startLocation: isSet(object.startLocation) ? globalThis.String(object.startLocation) : "",
      endLocation: isSet(object.endLocation) ? globalThis.String(object.endLocation) : "",
      passengerIds: globalThis.Array.isArray(object?.passengerIds)
        ? object.passengerIds.map((e: any) => globalThis.String(e))
        : [],
      dateTime: isSet(object.dateTime) ? globalThis.String(object.dateTime) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: GetRideResponse): unknown {
    const obj: any = {};
    if (message.rideId !== "") {
      obj.rideId = message.rideId;
    }
    if (message.driverId !== "") {
      obj.driverId = message.driverId;
    }
    if (message.startLocation !== "") {
      obj.startLocation = message.startLocation;
    }
    if (message.endLocation !== "") {
      obj.endLocation = message.endLocation;
    }
    if (message.passengerIds?.length) {
      obj.passengerIds = message.passengerIds;
    }
    if (message.dateTime !== "") {
      obj.dateTime = message.dateTime;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRideResponse>, I>>(base?: I): GetRideResponse {
    return GetRideResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRideResponse>, I>>(object: I): GetRideResponse {
    const message = createBaseGetRideResponse();
    message.rideId = object.rideId ?? "";
    message.driverId = object.driverId ?? "";
    message.startLocation = object.startLocation ?? "";
    message.endLocation = object.endLocation ?? "";
    message.passengerIds = object.passengerIds?.map((e) => e) || [];
    message.dateTime = object.dateTime ?? "";
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseListRidesRequest(): ListRidesRequest {
  return { driverId: "" };
}

export const ListRidesRequest: MessageFns<ListRidesRequest> = {
  encode(message: ListRidesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.driverId !== "") {
      writer.uint32(10).string(message.driverId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRidesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRidesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.driverId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRidesRequest {
    return { driverId: isSet(object.driverId) ? globalThis.String(object.driverId) : "" };
  },

  toJSON(message: ListRidesRequest): unknown {
    const obj: any = {};
    if (message.driverId !== "") {
      obj.driverId = message.driverId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRidesRequest>, I>>(base?: I): ListRidesRequest {
    return ListRidesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRidesRequest>, I>>(object: I): ListRidesRequest {
    const message = createBaseListRidesRequest();
    message.driverId = object.driverId ?? "";
    return message;
  },
};

function createBaseListRidesResponse(): ListRidesResponse {
  return { rides: [] };
}

export const ListRidesResponse: MessageFns<ListRidesResponse> = {
  encode(message: ListRidesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rides) {
      GetRideResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRidesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRidesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rides.push(GetRideResponse.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRidesResponse {
    return {
      rides: globalThis.Array.isArray(object?.rides) ? object.rides.map((e: any) => GetRideResponse.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListRidesResponse): unknown {
    const obj: any = {};
    if (message.rides?.length) {
      obj.rides = message.rides.map((e) => GetRideResponse.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRidesResponse>, I>>(base?: I): ListRidesResponse {
    return ListRidesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRidesResponse>, I>>(object: I): ListRidesResponse {
    const message = createBaseListRidesResponse();
    message.rides = object.rides?.map((e) => GetRideResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateRideRequest(): UpdateRideRequest {
  return { rideId: "", driverId: "", startLocation: "", endLocation: "", passengerIds: [], dateTime: "", status: "" };
}

export const UpdateRideRequest: MessageFns<UpdateRideRequest> = {
  encode(message: UpdateRideRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rideId !== "") {
      writer.uint32(10).string(message.rideId);
    }
    if (message.driverId !== "") {
      writer.uint32(18).string(message.driverId);
    }
    if (message.startLocation !== "") {
      writer.uint32(26).string(message.startLocation);
    }
    if (message.endLocation !== "") {
      writer.uint32(34).string(message.endLocation);
    }
    for (const v of message.passengerIds) {
      writer.uint32(42).string(v!);
    }
    if (message.dateTime !== "") {
      writer.uint32(50).string(message.dateTime);
    }
    if (message.status !== "") {
      writer.uint32(58).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateRideRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRideRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rideId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.driverId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.startLocation = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.endLocation = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.passengerIds.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.dateTime = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateRideRequest {
    return {
      rideId: isSet(object.rideId) ? globalThis.String(object.rideId) : "",
      driverId: isSet(object.driverId) ? globalThis.String(object.driverId) : "",
      startLocation: isSet(object.startLocation) ? globalThis.String(object.startLocation) : "",
      endLocation: isSet(object.endLocation) ? globalThis.String(object.endLocation) : "",
      passengerIds: globalThis.Array.isArray(object?.passengerIds)
        ? object.passengerIds.map((e: any) => globalThis.String(e))
        : [],
      dateTime: isSet(object.dateTime) ? globalThis.String(object.dateTime) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: UpdateRideRequest): unknown {
    const obj: any = {};
    if (message.rideId !== "") {
      obj.rideId = message.rideId;
    }
    if (message.driverId !== "") {
      obj.driverId = message.driverId;
    }
    if (message.startLocation !== "") {
      obj.startLocation = message.startLocation;
    }
    if (message.endLocation !== "") {
      obj.endLocation = message.endLocation;
    }
    if (message.passengerIds?.length) {
      obj.passengerIds = message.passengerIds;
    }
    if (message.dateTime !== "") {
      obj.dateTime = message.dateTime;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateRideRequest>, I>>(base?: I): UpdateRideRequest {
    return UpdateRideRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateRideRequest>, I>>(object: I): UpdateRideRequest {
    const message = createBaseUpdateRideRequest();
    message.rideId = object.rideId ?? "";
    message.driverId = object.driverId ?? "";
    message.startLocation = object.startLocation ?? "";
    message.endLocation = object.endLocation ?? "";
    message.passengerIds = object.passengerIds?.map((e) => e) || [];
    message.dateTime = object.dateTime ?? "";
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseUpdateRideResponse(): UpdateRideResponse {
  return { success: false };
}

export const UpdateRideResponse: MessageFns<UpdateRideResponse> = {
  encode(message: UpdateRideResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateRideResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRideResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateRideResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: UpdateRideResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateRideResponse>, I>>(base?: I): UpdateRideResponse {
    return UpdateRideResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateRideResponse>, I>>(object: I): UpdateRideResponse {
    const message = createBaseUpdateRideResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseDeleteRideRequest(): DeleteRideRequest {
  return { rideId: "" };
}

export const DeleteRideRequest: MessageFns<DeleteRideRequest> = {
  encode(message: DeleteRideRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rideId !== "") {
      writer.uint32(10).string(message.rideId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRideRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRideRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rideId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRideRequest {
    return { rideId: isSet(object.rideId) ? globalThis.String(object.rideId) : "" };
  },

  toJSON(message: DeleteRideRequest): unknown {
    const obj: any = {};
    if (message.rideId !== "") {
      obj.rideId = message.rideId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteRideRequest>, I>>(base?: I): DeleteRideRequest {
    return DeleteRideRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteRideRequest>, I>>(object: I): DeleteRideRequest {
    const message = createBaseDeleteRideRequest();
    message.rideId = object.rideId ?? "";
    return message;
  },
};

function createBaseDeleteRideResponse(): DeleteRideResponse {
  return { success: false };
}

export const DeleteRideResponse: MessageFns<DeleteRideResponse> = {
  encode(message: DeleteRideResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRideResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRideResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRideResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteRideResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteRideResponse>, I>>(base?: I): DeleteRideResponse {
    return DeleteRideResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteRideResponse>, I>>(object: I): DeleteRideResponse {
    const message = createBaseDeleteRideResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseFindRidesByLocationRequest(): FindRidesByLocationRequest {
  return { startLocation: "", endLocation: "" };
}

export const FindRidesByLocationRequest: MessageFns<FindRidesByLocationRequest> = {
  encode(message: FindRidesByLocationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startLocation !== "") {
      writer.uint32(10).string(message.startLocation);
    }
    if (message.endLocation !== "") {
      writer.uint32(18).string(message.endLocation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindRidesByLocationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindRidesByLocationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.startLocation = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.endLocation = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindRidesByLocationRequest {
    return {
      startLocation: isSet(object.startLocation) ? globalThis.String(object.startLocation) : "",
      endLocation: isSet(object.endLocation) ? globalThis.String(object.endLocation) : "",
    };
  },

  toJSON(message: FindRidesByLocationRequest): unknown {
    const obj: any = {};
    if (message.startLocation !== "") {
      obj.startLocation = message.startLocation;
    }
    if (message.endLocation !== "") {
      obj.endLocation = message.endLocation;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FindRidesByLocationRequest>, I>>(base?: I): FindRidesByLocationRequest {
    return FindRidesByLocationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FindRidesByLocationRequest>, I>>(object: I): FindRidesByLocationRequest {
    const message = createBaseFindRidesByLocationRequest();
    message.startLocation = object.startLocation ?? "";
    message.endLocation = object.endLocation ?? "";
    return message;
  },
};

function createBaseFindRidesByLocationResponse(): FindRidesByLocationResponse {
  return { rides: [] };
}

export const FindRidesByLocationResponse: MessageFns<FindRidesByLocationResponse> = {
  encode(message: FindRidesByLocationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rides) {
      GetRideResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindRidesByLocationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindRidesByLocationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rides.push(GetRideResponse.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindRidesByLocationResponse {
    return {
      rides: globalThis.Array.isArray(object?.rides) ? object.rides.map((e: any) => GetRideResponse.fromJSON(e)) : [],
    };
  },

  toJSON(message: FindRidesByLocationResponse): unknown {
    const obj: any = {};
    if (message.rides?.length) {
      obj.rides = message.rides.map((e) => GetRideResponse.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FindRidesByLocationResponse>, I>>(base?: I): FindRidesByLocationResponse {
    return FindRidesByLocationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FindRidesByLocationResponse>, I>>(object: I): FindRidesByLocationResponse {
    const message = createBaseFindRidesByLocationResponse();
    message.rides = object.rides?.map((e) => GetRideResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseJoinRideRequest(): JoinRideRequest {
  return { rideId: "", passengerId: "" };
}

export const JoinRideRequest: MessageFns<JoinRideRequest> = {
  encode(message: JoinRideRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rideId !== "") {
      writer.uint32(10).string(message.rideId);
    }
    if (message.passengerId !== "") {
      writer.uint32(18).string(message.passengerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JoinRideRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoinRideRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rideId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.passengerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JoinRideRequest {
    return {
      rideId: isSet(object.rideId) ? globalThis.String(object.rideId) : "",
      passengerId: isSet(object.passengerId) ? globalThis.String(object.passengerId) : "",
    };
  },

  toJSON(message: JoinRideRequest): unknown {
    const obj: any = {};
    if (message.rideId !== "") {
      obj.rideId = message.rideId;
    }
    if (message.passengerId !== "") {
      obj.passengerId = message.passengerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JoinRideRequest>, I>>(base?: I): JoinRideRequest {
    return JoinRideRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JoinRideRequest>, I>>(object: I): JoinRideRequest {
    const message = createBaseJoinRideRequest();
    message.rideId = object.rideId ?? "";
    message.passengerId = object.passengerId ?? "";
    return message;
  },
};

function createBaseJoinRideResponse(): JoinRideResponse {
  return { success: false };
}

export const JoinRideResponse: MessageFns<JoinRideResponse> = {
  encode(message: JoinRideResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JoinRideResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoinRideResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JoinRideResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: JoinRideResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JoinRideResponse>, I>>(base?: I): JoinRideResponse {
    return JoinRideResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JoinRideResponse>, I>>(object: I): JoinRideResponse {
    const message = createBaseJoinRideResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseLeaveRideRequest(): LeaveRideRequest {
  return { rideId: "", passengerId: "" };
}

export const LeaveRideRequest: MessageFns<LeaveRideRequest> = {
  encode(message: LeaveRideRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rideId !== "") {
      writer.uint32(10).string(message.rideId);
    }
    if (message.passengerId !== "") {
      writer.uint32(18).string(message.passengerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeaveRideRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaveRideRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rideId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.passengerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LeaveRideRequest {
    return {
      rideId: isSet(object.rideId) ? globalThis.String(object.rideId) : "",
      passengerId: isSet(object.passengerId) ? globalThis.String(object.passengerId) : "",
    };
  },

  toJSON(message: LeaveRideRequest): unknown {
    const obj: any = {};
    if (message.rideId !== "") {
      obj.rideId = message.rideId;
    }
    if (message.passengerId !== "") {
      obj.passengerId = message.passengerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LeaveRideRequest>, I>>(base?: I): LeaveRideRequest {
    return LeaveRideRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LeaveRideRequest>, I>>(object: I): LeaveRideRequest {
    const message = createBaseLeaveRideRequest();
    message.rideId = object.rideId ?? "";
    message.passengerId = object.passengerId ?? "";
    return message;
  },
};

function createBaseLeaveRideResponse(): LeaveRideResponse {
  return { success: false };
}

export const LeaveRideResponse: MessageFns<LeaveRideResponse> = {
  encode(message: LeaveRideResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeaveRideResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaveRideResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LeaveRideResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: LeaveRideResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LeaveRideResponse>, I>>(base?: I): LeaveRideResponse {
    return LeaveRideResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LeaveRideResponse>, I>>(object: I): LeaveRideResponse {
    const message = createBaseLeaveRideResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseChangeRideStatusRequest(): ChangeRideStatusRequest {
  return { rideId: "", status: "" };
}

export const ChangeRideStatusRequest: MessageFns<ChangeRideStatusRequest> = {
  encode(message: ChangeRideStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rideId !== "") {
      writer.uint32(10).string(message.rideId);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangeRideStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeRideStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rideId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangeRideStatusRequest {
    return {
      rideId: isSet(object.rideId) ? globalThis.String(object.rideId) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: ChangeRideStatusRequest): unknown {
    const obj: any = {};
    if (message.rideId !== "") {
      obj.rideId = message.rideId;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangeRideStatusRequest>, I>>(base?: I): ChangeRideStatusRequest {
    return ChangeRideStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangeRideStatusRequest>, I>>(object: I): ChangeRideStatusRequest {
    const message = createBaseChangeRideStatusRequest();
    message.rideId = object.rideId ?? "";
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseChangeRideStatusResponse(): ChangeRideStatusResponse {
  return { success: false };
}

export const ChangeRideStatusResponse: MessageFns<ChangeRideStatusResponse> = {
  encode(message: ChangeRideStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangeRideStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeRideStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangeRideStatusResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: ChangeRideStatusResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangeRideStatusResponse>, I>>(base?: I): ChangeRideStatusResponse {
    return ChangeRideStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangeRideStatusResponse>, I>>(object: I): ChangeRideStatusResponse {
    const message = createBaseChangeRideStatusResponse();
    message.success = object.success ?? false;
    return message;
  },
};

export interface RideService {
  CreateRide(request: CreateRideRequest): Promise<CreateRideResponse>;
  GetRide(request: GetRideRequest): Promise<GetRideResponse>;
  ListRides(request: ListRidesRequest): Promise<ListRidesResponse>;
  UpdateRide(request: UpdateRideRequest): Promise<UpdateRideResponse>;
  DeleteRide(request: DeleteRideRequest): Promise<DeleteRideResponse>;
  FindRidesByLocation(request: FindRidesByLocationRequest): Promise<FindRidesByLocationResponse>;
  JoinRide(request: JoinRideRequest): Promise<JoinRideResponse>;
  LeaveRide(request: LeaveRideRequest): Promise<LeaveRideResponse>;
  ChangeRideStatus(request: ChangeRideStatusRequest): Promise<ChangeRideStatusResponse>;
}

export const RideServiceServiceName = "rideservice.RideService";
export class RideServiceClientImpl implements RideService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || RideServiceServiceName;
    this.rpc = rpc;
    this.CreateRide = this.CreateRide.bind(this);
    this.GetRide = this.GetRide.bind(this);
    this.ListRides = this.ListRides.bind(this);
    this.UpdateRide = this.UpdateRide.bind(this);
    this.DeleteRide = this.DeleteRide.bind(this);
    this.FindRidesByLocation = this.FindRidesByLocation.bind(this);
    this.JoinRide = this.JoinRide.bind(this);
    this.LeaveRide = this.LeaveRide.bind(this);
    this.ChangeRideStatus = this.ChangeRideStatus.bind(this);
  }
  CreateRide(request: CreateRideRequest): Promise<CreateRideResponse> {
    const data = CreateRideRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateRide", data);
    return promise.then((data) => CreateRideResponse.decode(new BinaryReader(data)));
  }

  GetRide(request: GetRideRequest): Promise<GetRideResponse> {
    const data = GetRideRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetRide", data);
    return promise.then((data) => GetRideResponse.decode(new BinaryReader(data)));
  }

  ListRides(request: ListRidesRequest): Promise<ListRidesResponse> {
    const data = ListRidesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListRides", data);
    return promise.then((data) => ListRidesResponse.decode(new BinaryReader(data)));
  }

  UpdateRide(request: UpdateRideRequest): Promise<UpdateRideResponse> {
    const data = UpdateRideRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateRide", data);
    return promise.then((data) => UpdateRideResponse.decode(new BinaryReader(data)));
  }

  DeleteRide(request: DeleteRideRequest): Promise<DeleteRideResponse> {
    const data = DeleteRideRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteRide", data);
    return promise.then((data) => DeleteRideResponse.decode(new BinaryReader(data)));
  }

  FindRidesByLocation(request: FindRidesByLocationRequest): Promise<FindRidesByLocationResponse> {
    const data = FindRidesByLocationRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "FindRidesByLocation", data);
    return promise.then((data) => FindRidesByLocationResponse.decode(new BinaryReader(data)));
  }

  JoinRide(request: JoinRideRequest): Promise<JoinRideResponse> {
    const data = JoinRideRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "JoinRide", data);
    return promise.then((data) => JoinRideResponse.decode(new BinaryReader(data)));
  }

  LeaveRide(request: LeaveRideRequest): Promise<LeaveRideResponse> {
    const data = LeaveRideRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "LeaveRide", data);
    return promise.then((data) => LeaveRideResponse.decode(new BinaryReader(data)));
  }

  ChangeRideStatus(request: ChangeRideStatusRequest): Promise<ChangeRideStatusResponse> {
    const data = ChangeRideStatusRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ChangeRideStatus", data);
    return promise.then((data) => ChangeRideStatusResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
